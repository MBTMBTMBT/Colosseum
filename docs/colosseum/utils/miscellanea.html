<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>colosseum.utils.miscellanea API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>colosseum.utils.miscellanea</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cProfile
import importlib
import inspect
import os
from glob import glob
from io import StringIO
from typing import TYPE_CHECKING, Iterable, List, Type, Union, Any

import dm_env
import numpy as np
from scipy.stats import rv_continuous
from tqdm import tqdm

import colosseum.config as config

if TYPE_CHECKING:
    from colosseum.mdp import BaseMDP


def get_empty_ts(state : Any) -&gt; dm_env.TimeStep:
    return dm_env.TimeStep(dm_env.StepType.MID, 0, 0, state)


def profile(file_path):
    def decorator(f):
        print(f&#34;Profiling {f}&#34;)

        def inner(*args, **kwargs):
            pr = cProfile.Profile()
            pr.enable()
            f(*args, **kwargs)
            pr.disable()
            # after your program ends
            pr.dump_stats(file_path)

        return inner

    return decorator


def get_colosseum_mdp_classes(episodic: bool = None) -&gt; List[Type[&#34;BaseMDP&#34;]]:
    if episodic is None:
        return _get_colosseum_mdp_classes() + _get_colosseum_mdp_classes(False)
    if episodic:
        return _get_colosseum_mdp_classes()
    return _get_colosseum_mdp_classes(False)


def _get_colosseum_mdp_classes(episodic=True):
    import colosseum

    mdp_path = &#34;finite_horizon&#34; if episodic else &#34;infinite_horizon&#34;
    return [
        importlib.import_module(
            mdp_file[mdp_file.find(&#34;colosseum&#34;) : mdp_file.find(mdp_path) - 1].replace(
                os.sep, &#34;.&#34;
            )
            + &#34;.&#34;
            + mdp_path
        ).MDPClass
        for mdp_file in glob(
            f&#34;{os.path.dirname(inspect.getfile(colosseum))}{os.sep}mdp{os.sep}**{os.sep}{mdp_path}.py&#34;,
            recursive=True,
        )
    ]


def get_mdp_class_from_name(mdp_class_name: str):
    try:
        return next(
            filter(lambda c: c.__name__ == mdp_class_name, get_colosseum_mdp_classes())
        )
    except StopIteration:
        raise ModuleNotFoundError(
            f&#34;The {mdp_class_name} was not found in colosseum. Please check the correct spelling and the result of &#34;
            f&#34;get_colosseum_mdp_classes()&#34;
        )


def get_colosseum_agent_classes(episodic=None):
    from colosseum.agent.agents.episodic import EPISODIC_AGENT_CLASSES
    from colosseum.agent.agents.infinite_horizon import (
        INFINITE_HORIZON_AGENT_CLASSES,
    )

    if episodic is None:
        return EPISODIC_AGENT_CLASSES + INFINITE_HORIZON_AGENT_CLASSES
    if episodic:
        return EPISODIC_AGENT_CLASSES
    return INFINITE_HORIZON_AGENT_CLASSES


def _get_colosseum_agent_classes(episodic=True):
    from colosseum.agent.agents.episodic import EPISODIC_AGENT_CLASSES
    from colosseum.agent.agents.infinite_horizon import (
        INFINITE_HORIZON_AGENT_CLASSES,
    )

    if episodic:
        return EPISODIC_AGENT_CLASSES
    return INFINITE_HORIZON_AGENT_CLASSES


def get_agent_class_from_name(agent_class_name: str):
    try:
        return next(
            filter(
                lambda c: c.__name__ == agent_class_name,
                get_colosseum_agent_classes() + config.get_external_agent_classes(),
            )
        )
    except StopIteration:
        raise ModuleNotFoundError(
            f&#34;The {agent_class_name} was not found in colosseum. Please check the correct spelling and the result of &#34;
            f&#34;get_colosseum_agent_classes(). If you have implemented the {agent_class_name}, please make sure to update&#34;
            f&#34;the lists of agents in colosseum/agent/agents/episodic/__init__.py and &#34;
            f&#34;colosseum/agent/agents/continuous/__init__.py&#34;
        )


def ensure_folder(path: str) -&gt; str:
    return path if path[-1] == os.sep else (path + os.sep)


def get_dist(dist_name, args):
    return importlib.import_module(f&#34;scipy.stats&#34;).__getattribute__(dist_name)(*args)


class deterministic_gen(rv_continuous):
    def _cdf(self, x):
        return np.where(x &lt; 0, 0.0, 1.0)

    def _stats(self):
        return 0.0, 0.0, 0.0, 0.0

    def _rvs(self, size=None, random_state=None):
        return np.zeros(shape=size)


deterministic = deterministic_gen(name=&#34;deterministic&#34;)


def state_occurencens_to_counts(occurences: List[int], N: int) -&gt; np.ndarray:
    x = np.zeros(N)
    for s, c in dict(zip(*np.unique(occurences, return_counts=True))).items():
        x[s] = c
    return x


def check_distributions(dists: List[Union[rv_continuous, None]], are_stochastic: bool):
    &#34;&#34;&#34;
    checks that the distribution given in input respects the necessary conditions.

    Parameters
    ----------
    dists : List[Union[rv_continuous, None]]
        is the list of distributions.
    are_stochastic : bool
        whether the distributions are supposed to be stochastic.
    &#34;&#34;&#34;
    # You either define all or none of the distribution
    assert dists.count(None) in [0, len(dists)]

    # Double check that the distributions in input matches the stochasticity of the reward parameter
    if dists[0] is not None:
        if are_stochastic:
            assert all(type(dist.dist) != deterministic_gen for dist in dists)
        else:
            assert all(type(dist.dist) == deterministic_gen for dist in dists)


def get_loop(x: Iterable):
    &#34;&#34;&#34;
    returns an iterable that respects the current level of verbosity.
    &#34;&#34;&#34;
    if config.VERBOSE_LEVEL != 0:
        if type(config.VERBOSE_LEVEL) == int:
            return tqdm(x, desc=&#34;Diameter calculation&#34;, mininterval=5)
        s = StringIO()
        return tqdm(x, desc=&#34;Diameter calculation&#34;, file=s, mininterval=5)
    return x</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="colosseum.utils.miscellanea.check_distributions"><code class="name flex">
<span>def <span class="ident">check_distributions</span></span>(<span>dists: List[Optional[scipy.stats._distn_infrastructure.rv_continuous]], are_stochastic: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>checks that the distribution given in input respects the necessary conditions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dists</code></strong> :&ensp;<code>List[Union[rv_continuous, None]]</code></dt>
<dd>is the list of distributions.</dd>
<dt><strong><code>are_stochastic</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether the distributions are supposed to be stochastic.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_distributions(dists: List[Union[rv_continuous, None]], are_stochastic: bool):
    &#34;&#34;&#34;
    checks that the distribution given in input respects the necessary conditions.

    Parameters
    ----------
    dists : List[Union[rv_continuous, None]]
        is the list of distributions.
    are_stochastic : bool
        whether the distributions are supposed to be stochastic.
    &#34;&#34;&#34;
    # You either define all or none of the distribution
    assert dists.count(None) in [0, len(dists)]

    # Double check that the distributions in input matches the stochasticity of the reward parameter
    if dists[0] is not None:
        if are_stochastic:
            assert all(type(dist.dist) != deterministic_gen for dist in dists)
        else:
            assert all(type(dist.dist) == deterministic_gen for dist in dists)</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.ensure_folder"><code class="name flex">
<span>def <span class="ident">ensure_folder</span></span>(<span>path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_folder(path: str) -&gt; str:
    return path if path[-1] == os.sep else (path + os.sep)</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.get_agent_class_from_name"><code class="name flex">
<span>def <span class="ident">get_agent_class_from_name</span></span>(<span>agent_class_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_agent_class_from_name(agent_class_name: str):
    try:
        return next(
            filter(
                lambda c: c.__name__ == agent_class_name,
                get_colosseum_agent_classes() + config.get_external_agent_classes(),
            )
        )
    except StopIteration:
        raise ModuleNotFoundError(
            f&#34;The {agent_class_name} was not found in colosseum. Please check the correct spelling and the result of &#34;
            f&#34;get_colosseum_agent_classes(). If you have implemented the {agent_class_name}, please make sure to update&#34;
            f&#34;the lists of agents in colosseum/agent/agents/episodic/__init__.py and &#34;
            f&#34;colosseum/agent/agents/continuous/__init__.py&#34;
        )</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.get_colosseum_agent_classes"><code class="name flex">
<span>def <span class="ident">get_colosseum_agent_classes</span></span>(<span>episodic=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_colosseum_agent_classes(episodic=None):
    from colosseum.agent.agents.episodic import EPISODIC_AGENT_CLASSES
    from colosseum.agent.agents.infinite_horizon import (
        INFINITE_HORIZON_AGENT_CLASSES,
    )

    if episodic is None:
        return EPISODIC_AGENT_CLASSES + INFINITE_HORIZON_AGENT_CLASSES
    if episodic:
        return EPISODIC_AGENT_CLASSES
    return INFINITE_HORIZON_AGENT_CLASSES</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.get_colosseum_mdp_classes"><code class="name flex">
<span>def <span class="ident">get_colosseum_mdp_classes</span></span>(<span>episodic: bool = None) ‑> List[Type[BaseMDP]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_colosseum_mdp_classes(episodic: bool = None) -&gt; List[Type[&#34;BaseMDP&#34;]]:
    if episodic is None:
        return _get_colosseum_mdp_classes() + _get_colosseum_mdp_classes(False)
    if episodic:
        return _get_colosseum_mdp_classes()
    return _get_colosseum_mdp_classes(False)</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.get_dist"><code class="name flex">
<span>def <span class="ident">get_dist</span></span>(<span>dist_name, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dist(dist_name, args):
    return importlib.import_module(f&#34;scipy.stats&#34;).__getattribute__(dist_name)(*args)</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.get_empty_ts"><code class="name flex">
<span>def <span class="ident">get_empty_ts</span></span>(<span>state: Any) ‑> dm_env._environment.TimeStep</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_empty_ts(state : Any) -&gt; dm_env.TimeStep:
    return dm_env.TimeStep(dm_env.StepType.MID, 0, 0, state)</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.get_loop"><code class="name flex">
<span>def <span class="ident">get_loop</span></span>(<span>x: Iterable[+T_co])</span>
</code></dt>
<dd>
<div class="desc"><p>returns an iterable that respects the current level of verbosity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_loop(x: Iterable):
    &#34;&#34;&#34;
    returns an iterable that respects the current level of verbosity.
    &#34;&#34;&#34;
    if config.VERBOSE_LEVEL != 0:
        if type(config.VERBOSE_LEVEL) == int:
            return tqdm(x, desc=&#34;Diameter calculation&#34;, mininterval=5)
        s = StringIO()
        return tqdm(x, desc=&#34;Diameter calculation&#34;, file=s, mininterval=5)
    return x</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.get_mdp_class_from_name"><code class="name flex">
<span>def <span class="ident">get_mdp_class_from_name</span></span>(<span>mdp_class_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mdp_class_from_name(mdp_class_name: str):
    try:
        return next(
            filter(lambda c: c.__name__ == mdp_class_name, get_colosseum_mdp_classes())
        )
    except StopIteration:
        raise ModuleNotFoundError(
            f&#34;The {mdp_class_name} was not found in colosseum. Please check the correct spelling and the result of &#34;
            f&#34;get_colosseum_mdp_classes()&#34;
        )</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.profile"><code class="name flex">
<span>def <span class="ident">profile</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def profile(file_path):
    def decorator(f):
        print(f&#34;Profiling {f}&#34;)

        def inner(*args, **kwargs):
            pr = cProfile.Profile()
            pr.enable()
            f(*args, **kwargs)
            pr.disable()
            # after your program ends
            pr.dump_stats(file_path)

        return inner

    return decorator</code></pre>
</details>
</dd>
<dt id="colosseum.utils.miscellanea.state_occurencens_to_counts"><code class="name flex">
<span>def <span class="ident">state_occurencens_to_counts</span></span>(<span>occurences: List[int], N: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state_occurencens_to_counts(occurences: List[int], N: int) -&gt; np.ndarray:
    x = np.zeros(N)
    for s, c in dict(zip(*np.unique(occurences, return_counts=True))).items():
        x[s] = c
    return x</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="colosseum.utils.miscellanea.deterministic_gen"><code class="flex name class">
<span>class <span class="ident">deterministic_gen</span></span>
<span>(</span><span>momtype=1, a=None, b=None, xtol=1e-14, badvalue=None, name=None, longname=None, shapes=None, extradoc=None, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic continuous random variable class meant for subclassing.</p>
<p><code>rv_continuous</code> is a base class to construct specific distribution classes
and instances for continuous random variables. It cannot be used
directly as a distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>momtype</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The type of generic moment calculation to use: 0 for pdf, 1 (default)
for ppf.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Lower bound of the support of the distribution, default is minus
infinity.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Upper bound of the support of the distribution, default is plus
infinity.</dd>
<dt><strong><code>xtol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The tolerance for fixed point calculation for generic ppf.</dd>
<dt><strong><code>badvalue</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The value in a result arrays that indicates a value that for which
some argument restriction is violated, default is np.nan.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the instance. This string is used to construct the default
example for distributions.</dd>
<dt><strong><code>longname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This string is used as part of the first line of the docstring returned
when a subclass has no docstring of its own. Note: <code>longname</code> exists
for backwards compatibility, do not use for new subclasses.</dd>
<dt><strong><code>shapes</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The shape of the distribution. For example <code>"m, n"</code> for a
distribution that takes two integers as the two shape arguments for all
its methods. If not provided, shape parameters will be inferred from
the signature of the private methods, <code>_pdf</code> and <code>_cdf</code> of the
instance.</dd>
<dt><strong><code>extradoc</code></strong> :&ensp;<code> str</code>, optional<code>, deprecated</code></dt>
<dd>This string is used as the last part of the docstring returned when a
subclass has no docstring of its own. Note: <code>extradoc</code> exists for
backwards compatibility, do not use for new subclasses.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>{None, int,</code>numpy.random.Generator<code>,</code></dt>
<dd>
<p><code>numpy.random.RandomState</code>}, optional</p>
<p>If <code>seed</code> is None (or <code>np.random</code>), the <code>numpy.random.RandomState</code>
singleton is used.
If <code>seed</code> is an int, a new <code>RandomState</code> instance is used,
seeded with <code>seed</code>.
If <code>seed</code> is already a <code>Generator</code> or <code>RandomState</code> instance then
that instance is used.</p>
</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>rvs
pdf
logpdf
cdf
logcdf
sf
logsf
ppf
isf
moment
stats
entropy
expect
median
mean
std
var
interval
<strong>call</strong>
fit
fit_loc_scale
nnlf
support</p>
<h2 id="notes">Notes</h2>
<p>Public methods of an instance of a distribution class (e.g., <code>pdf</code>,
<code>cdf</code>) check their arguments and pass valid arguments to private,
computational methods (<code>_pdf</code>, <code>_cdf</code>). For <code>pdf(x)</code>, <code>x</code> is valid
if it is within the support of the distribution.
Whether a shape parameter is valid is decided by an <code>_argcheck</code> method
(which defaults to checking that its arguments are strictly positive.)</p>
<p><strong>Subclassing</strong></p>
<p>New random variables can be defined by subclassing the <code>rv_continuous</code> class
and re-defining at least the <code>_pdf</code> or the <code>_cdf</code> method (normalized
to location 0 and scale 1).</p>
<p>If positive argument checking is not correct for your RV
then you will also need to re-define the <code>_argcheck</code> method.</p>
<p>For most of the scipy.stats distributions, the support interval doesn't
depend on the shape parameters. <code>x</code> being in the support interval is
equivalent to <code>self.a &lt;= x &lt;= self.b</code>.
If either of the endpoints of
the support do depend on the shape parameters, then
i) the distribution must implement the <code>_get_support</code> method; and
ii) those dependent endpoints must be omitted from the distribution's
call to the <code>rv_continuous</code> initializer.</p>
<p>Correct, but potentially slow defaults exist for the remaining
methods but for speed and/or accuracy you can over-ride::</p>
<p>_logpdf, _cdf, _logcdf, _ppf, _rvs, _isf, _sf, _logsf</p>
<p>The default method <code>_rvs</code> relies on the inverse of the cdf, <code>_ppf</code>,
applied to a uniform random variate. In order to generate random variates
efficiently, either the default <code>_ppf</code> needs to be overwritten (e.g.
if the inverse cdf can expressed in an explicit form) or a sampling
method needs to be implemented in a custom <code>_rvs</code> method.</p>
<p>If possible, you should override <code>_isf</code>, <code>_sf</code> or <code>_logsf</code>.
The main reason would be to improve numerical accuracy: for example,
the survival function <code>_sf</code> is computed as <code>1 - _cdf</code> which can
result in loss of precision if <code>_cdf(x)</code> is close to one.</p>
<p><strong>Methods that can be overwritten by subclasses</strong>
::</p>
<p>_rvs
_pdf
_cdf
_sf
_ppf
_isf
_stats
_munp
_entropy
_argcheck
_get_support</p>
<p>There are additional (internal and private) generic methods that can
be useful for cross-checking and for debugging, but might work in all
cases when directly called.</p>
<p>A note on <code>shapes</code>: subclasses need not specify them explicitly. In this
case, <code>shapes</code> will be automatically deduced from the signatures of the
overridden methods (<code>pdf</code>, <code>cdf</code> etc).
If, for some reason, you prefer to avoid relying on introspection, you can
specify <code>shapes</code> explicitly as an argument to the instance constructor.</p>
<p><strong>Frozen Distributions</strong></p>
<p>Normally, you must provide shape parameters (and, optionally, location and
scale parameters to each call of a method of a distribution.</p>
<p>Alternatively, the object may be called (as a function) to fix the shape,
location, and scale parameters returning a "frozen" continuous RV object:</p>
<p>rv = generic(<shape(s)>, loc=0, scale=1)
<code>rv_frozen</code> object with the same methods but holding the given shape,
location, and scale fixed</p>
<p><strong>Statistics</strong></p>
<p>Statistics are computed using numerical integration by default.
For speed you can redefine this using <code>_stats</code>:</p>
<ul>
<li>take shape parameters and return mu, mu2, g1, g2</li>
<li>If you can't compute one of these, return it as None</li>
<li>Can also be defined with a keyword argument <code>moments</code>, which is a
string composed of "m", "v", "s", and/or "k".
Only the components appearing in string should be computed and
returned in the order "m", "v", "s", or "k"
with missing values
returned as None.</li>
</ul>
<p>Alternatively, you can override <code>_munp</code>, which takes <code>n</code> and shape
parameters and returns the n-th non-central moment of the distribution.</p>
<h2 id="examples">Examples</h2>
<p>To create a new Gaussian distribution, we would do the following:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from scipy.stats import rv_continuous
&gt;&gt;&gt; class gaussian_gen(rv_continuous):
...     &quot;Gaussian distribution&quot;
...     def _pdf(self, x):
...         return np.exp(-x**2 / 2.) / np.sqrt(2.0 * np.pi)
&gt;&gt;&gt; gaussian = gaussian_gen(name='gaussian')
</code></pre>
<p><code>scipy.stats</code> distributions are <em>instances</em>, so here we subclass
<code>rv_continuous</code> and create an instance. With this, we now have
a fully functional distribution with all relevant methods automagically
generated by the framework.</p>
<p>Note that above we defined a standard normal distribution, with zero mean
and unit variance. Shifting and scaling of the distribution can be done
by using <code>loc</code> and <code>scale</code> parameters: <code>gaussian.pdf(x, loc, scale)</code>
essentially computes <code>y = (x - loc) / scale</code> and
<code>gaussian._pdf(y) / scale</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class deterministic_gen(rv_continuous):
    def _cdf(self, x):
        return np.where(x &lt; 0, 0.0, 1.0)

    def _stats(self):
        return 0.0, 0.0, 0.0, 0.0

    def _rvs(self, size=None, random_state=None):
        return np.zeros(shape=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scipy.stats._distn_infrastructure.rv_continuous</li>
<li>scipy.stats._distn_infrastructure.rv_generic</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="colosseum.utils" href="index.html">colosseum.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="colosseum.utils.miscellanea.check_distributions" href="#colosseum.utils.miscellanea.check_distributions">check_distributions</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.ensure_folder" href="#colosseum.utils.miscellanea.ensure_folder">ensure_folder</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.get_agent_class_from_name" href="#colosseum.utils.miscellanea.get_agent_class_from_name">get_agent_class_from_name</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.get_colosseum_agent_classes" href="#colosseum.utils.miscellanea.get_colosseum_agent_classes">get_colosseum_agent_classes</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.get_colosseum_mdp_classes" href="#colosseum.utils.miscellanea.get_colosseum_mdp_classes">get_colosseum_mdp_classes</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.get_dist" href="#colosseum.utils.miscellanea.get_dist">get_dist</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.get_empty_ts" href="#colosseum.utils.miscellanea.get_empty_ts">get_empty_ts</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.get_loop" href="#colosseum.utils.miscellanea.get_loop">get_loop</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.get_mdp_class_from_name" href="#colosseum.utils.miscellanea.get_mdp_class_from_name">get_mdp_class_from_name</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.profile" href="#colosseum.utils.miscellanea.profile">profile</a></code></li>
<li><code><a title="colosseum.utils.miscellanea.state_occurencens_to_counts" href="#colosseum.utils.miscellanea.state_occurencens_to_counts">state_occurencens_to_counts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="colosseum.utils.miscellanea.deterministic_gen" href="#colosseum.utils.miscellanea.deterministic_gen">deterministic_gen</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>