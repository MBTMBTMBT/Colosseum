<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>colosseum.hardness.measures.diameter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>colosseum.hardness.measures.diameter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from io import StringIO
from multiprocessing import Pool
from typing import TYPE_CHECKING, Iterable

import networkx as nx
import numba
import numpy as np
import sparse
from tqdm import tqdm, trange

from colosseum import config
from colosseum.dynamic_programming import discounted_value_iteration, episodic_value_iteration
from colosseum.utils import get_loop

if TYPE_CHECKING:
    from colosseum.mdp import NODE_TYPE


def get_diameter(T: np.ndarray, is_episodic: bool, max_value: float = None) -&gt; float:
    &#34;&#34;&#34;
    returns the diameter for the transition matrix given in input. The is_episodic is only necessary to check whether
    the dimensionality of the transition matrix is effectively correct. Note that, for the episodic setting, this
    computes the diameter for the augmented state space.
    &#34;&#34;&#34;
    assert (is_episodic and T.ndim == 4) or (not is_episodic and T.ndim == 3)
    if is_episodic:
        if config.get_available_cores() &gt;= 3:
            return _multi_thread_episodic_diameter_calculation(T, max_value=max_value)
        return _single_thread_episodic_diameter_calculation(T, max_value=max_value)

    if config.get_available_cores() &gt;= 3:
        return _continuous_multi_thread_diam(T, max_value=max_value)
    if T.shape[-1] &gt; 1000:
        return _get_sparse_diameter(T, max_value=max_value)
    return _continuous_single_thread_diam(T, max_value=max_value)


def get_in_episodic_diameter(
    H: int,
    T: np.ndarray,
    reachable_node: Iterable[&#34;NODE_TYPE&#34;],
    max_value: float = None,
) -&gt; float:
    &#34;&#34;&#34;
    returns the diameter for the in episodic formulation. Note that in this case, the diameter will always be less than
    the time horizon.
    &#34;&#34;&#34;
    if config.get_available_cores() &gt;= 3:
        return _episodic_multi_thread_diam(H, T, reachable_node, max_value)
    return _episodic_single_thread_diam(H, T, reachable_node, max_value)


def get_diameter_for_determinsitic_MDPs(G: nx.DiGraph) -&gt; float:
    &#34;&#34;&#34;
    returns the diameter for the given graph that represents an MDP. Note that this can be considerably slower than
    the dynamic programming implementation we propose.
    &#34;&#34;&#34;
    A = nx.to_numpy_array(G, nonedge=np.inf)
    n, m = A.shape
    np.fill_diagonal(A, 0)  # diagonal elements should be zero
    for i in get_loop(range(n)):
        A = np.minimum(A, A[i, :][np.newaxis, :] + A[:, i][:, np.newaxis])
    return np.max(A, where=A != 0, initial=-np.inf)


def _continuous_diam_calculation(
    es: int, T: np.ndarray, max_value: float = None
) -&gt; float:
    &#34;&#34;&#34;
    returns the highest optimal expected number of time step to reach es among all other states in the continuous setting
    &#34;&#34;&#34;
    T_es = T.copy()
    T_es[es] = 0
    T_es[es, :, es] = 1

    R_es = np.zeros(T.shape[:2], np.float32) - 1.0
    R_es[es] = 0
    res = discounted_value_iteration(T_es, R_es, 1, max_abs_value=max_value)
    if res is None:
        return None
    _, V = res
    return -V.min()


def _continuous_single_thread_diam(T: np.ndarray, max_value: float = None) -&gt; float:
    diameter = 0
    for es in get_loop(range(len(T))):
        diameter = max(
            diameter, _continuous_diam_calculation(es, T, max_value=max_value)
        )
        if max_value is not None and diameter &gt; max_value:
            return None
    return diameter


def _continuous_multi_thread_diam(T: np.ndarray, max_value: float = None) -&gt; float:
    loop = get_loop(range(len(T)))
    diameter = 0
    with Pool(processes=config.get_available_cores()) as p:
        for d in p.starmap(
            _continuous_diam_calculation, [[es, T, max_value] for es in range(len(T))]
        ):
            if max_value is not None and d is None:
                diameter = None
                break
            diameter = max(diameter, d)
            if config.VERBOSE_LEVEL &gt; 0:
                loop.set_description(f&#34;Max diam: {diameter:.2f}&#34;)
                loop.update()
                loop.refresh()
    return diameter


def _episodic_diam_calculation(
    es: int,
    T: np.ndarray,
    H: int,
    reachable_states: Iterable[&#34;NODE_TYPE&#34;],
    max_value: float = None,
) -&gt; float:
    &#34;&#34;&#34;
    returns the highest optimal expected number of time step to reach es among all other states in the episodic setting
    &#34;&#34;&#34;
    T_es = T.copy()
    T_es[es] = 0
    T_es[es, :, es] = 1

    R_es = np.zeros(T.shape[:2], np.float32) - 1.0
    R_es[es] = 0
    res = episodic_value_iteration(H, T_es, R_es, max_abs_value=max_value)
    if res is None:
        return None
    _, V = res
    return max(-V[h, s] for h, s in reachable_states)


def _episodic_single_thread_diam(
    H: int,
    T: np.ndarray,
    reachable_states: Iterable[&#34;NODE_TYPE&#34;],
    max_value: float = None,
) -&gt; float:
    assert (
        len(T.shape) == 3
    ), &#34;The transition matrix is incorrect. Please provide the non episodic transition matrix.&#34;
    diam = 0
    for es in get_loop(range(len(T))):
        diam = max(
            diam,
            _episodic_diam_calculation(es, T, H, reachable_states, max_value=max_value),
        )
        if max_value is not None and diam &gt; max_value:
            return None
    return diam


def _episodic_multi_thread_diam(
    H: int,
    T: np.ndarray,
    reachable_states: Iterable[&#34;NODE_TYPE&#34;],
    max_value: float = None,
) -&gt; float:
    loop = get_loop(range(len(T)))
    diam = 0
    with Pool(processes=config.get_available_cores()) as p:
        for d in p.starmap(
            _episodic_diam_calculation,
            [[es, T, H, reachable_states, max_value] for es in range(len(T))],
        ):
            diam = max(diam, d)
            if max_value is not None and diam &gt; max_value:
                return None
            if config.VERBOSE_LEVEL &gt; 0:
                loop.set_description(f&#34;Max diam: {diam:.2f}&#34;)
                loop.update()
                loop.refresh()
    return diam


def _single_thread_episodic_diameter_calculation(
    T: np.ndarray,
    states: Iterable[&#34;NODE_TYPE&#34;] = None,
    epsilon=0.001,
    max_value: float = None,
) -&gt; float:
    if states is None:
        num_states = T.shape[-1]
        states = range(num_states)

    diameter = -np.inf
    states = list(reversed(states))

    if config.VERBOSE_LEVEL != 0:
        if type(config.VERBOSE_LEVEL) == int:
            loop = tqdm(states, desc=&#34;Diameter calculation&#34;, mininterval=5)
        else:
            s = StringIO()
            loop = tqdm(states, desc=&#34;Diameter calculation&#34;, file=s, mininterval=5)
    else:
        loop = states

    dima_f = (
        _continuous_diameter_calculation
        if T.ndim == 3
        else _episodic_diameter_calculation
    )
    for es in loop:
        diameter = dima_f(es, T, diameter, epsilon, max_value)
        if max_value is not None and diameter &gt; max_value:
            return None
        if config.VERBOSE_LEVEL != 0 and type(config.VERBOSE_LEVEL) == str:
            with open(config.VERBOSE_LEVEL, &#34;a&#34;) as f:
                f.write(
                    s.getvalue()
                    .split(&#34;\x1b&#34;)[0][2:]
                    .replace(&#34;\x00&#34;, &#34;&#34;)
                    .replace(&#34;\n\r&#34;, &#34;&#34;)
                    + &#34;\n&#34;
                )
            s.truncate(0)
    return diameter


def _d_imap(args):
    T, state_set, epsilon, sparse_T, max_value = args
    if sparse_T:
        num_states, num_sa = T.shape[-2:]
        diam = 0
        for es in state_set:
            diam = _sparse_diameter_calculation(
                es, T, int(num_sa / num_states), num_states, diam, epsilon, max_value
            )
        return diam
    return _single_thread_episodic_diameter_calculation(
        T, state_set, epsilon, max_value
    )


def _multi_thread_episodic_diameter_calculation(
    T: np.ndarray,
    epsilon: float = 0.001,
    force_sparse: bool = False,
    max_value: float = None,
) -&gt; float:
    num_actions, num_states = T.shape[-2:]
    diameter = -np.inf

    sparse_T = False
    if force_sparse or (num_states &gt; 500 and T.ndim == 3):
        T = np.moveaxis(T, -1, 0).reshape(num_states, num_states * num_actions)
        T = sparse.COO(T)
        sparse_T = True

    states = np.arange(num_states)[::-1]
    # np.random.shuffle(states)
    states_sets = np.array_split(states, config.get_available_cores())
    inputs = [(T, state_set, epsilon, sparse_T, max_value) for state_set in states_sets]
    if config.VERBOSE_LEVEL &gt; 0:
        loop = trange(len(inputs), desc=&#34;Diameter calculation&#34;, mininterval=5)
    with Pool(processes=config.get_available_cores()) as p:
        for d in p.imap_unordered(_d_imap, inputs):
            if max_value is not None and d is None:
                diameter = None
                break
            diameter = max(diameter, d)
            if config.VERBOSE_LEVEL &gt; 0:
                loop.update()
                loop.set_description(f&#34;Max diam: {diameter:.2f}&#34;)
    return diameter


@numba.njit()
def _episodic_diameter_calculation(
    es: int,
    T: np.ndarray,
    max_diam: float,
    epsilon: float = 0.001,
    max_value: float = None,
) -&gt; float:
    H, num_states, num_actions, _ = T.shape
    ETs = np.zeros((H, num_states), dtype=np.float32)
    ET_minh = np.zeros((num_states,), dtype=np.float32)
    for t in range(1_000_000):
        ETs_old = ETs.copy()
        ETs[-1] = T[-1, 0, 0] @ (1 + ETs[0])
        for hh in range(1, H):
            h = H - hh
            for j in range(num_states):
                if j != es:
                    s = np.zeros(num_actions, np.float32)
                    for ns in range(num_states):
                        if ns != es:
                            s += T[h - 1, j, :, ns] * (1 + ETs[h, ns])
                    ETs[h - 1, j] = np.min(T[h - 1, j, :, es] + s)
                    if max_value is not None and ETs[h - 1, j] &gt; max_value:
                        return None

        diff = np.abs(ETs_old - ETs).max()
        for ss in range(num_states):
            ccc = ETs[:, ss]
            ET_minh[ss] = np.min(ccc[ccc &gt; 0])
        cur_diam = ET_minh.max()
        if diff &lt; epsilon or (diff &lt; 0.01 and cur_diam - 1 &lt; max_diam):
            break
    return max(max_diam, cur_diam)


@numba.njit()
def _continuous_diameter_calculation(
    es: &#34;NODE_TYPE&#34;,
    T: np.ndarray,
    max_diam: float,
    epsilon: float = 0.001,
    max_value: float = None,
) -&gt; float:
    num_states, num_actions, _ = T.shape
    ETs = np.zeros(num_states, dtype=np.float32)
    for t in range(1_000_000):
        ETs_old = ETs.copy()
        for j in range(num_states):
            if j != es:
                s = np.zeros(num_actions, np.float32)
                for ns in range(num_states):
                    if ns != es:
                        s += T[j, :, ns] * (1 + ETs[ns])
                ETs[j] = np.min(T[j, :, es] + s)
                if max_value is not None and ETs[j].max() &gt; max_value:
                    return None

        diff = np.abs(ETs_old - ETs).max()
        if diff &lt; epsilon or (diff &lt; 0.05 and ETs.max() - 1 &lt; max_diam):
            break
    return max(max_diam, ETs.max())


def _sparse_diameter_calculation(
    es: &#34;NODE_TYPE&#34;,
    T: np.ndarray,
    num_actions: int,
    num_states: int,
    max_diam: float,
    epsilon: float = 0.001,
    max_value: float = None,
) -&gt; float:
    ETs = np.zeros(num_states - 1, dtype=np.float32)

    next_ets = (
        lambda TT, ET: (TT * ET.reshape((-1, 1)))
        .reshape((num_states - 1, num_states, num_actions))
        .sum(0)
        .todense()
    )
    selector = np.ones(num_states, dtype=bool)
    selector[es] = False
    Te = T[es].reshape((num_states, num_actions))
    T_me = T[selector]

    for j in range(1_000_000):
        ETs_old = ETs.copy()
        ETs = (Te + next_ets(T_me, 1 + ETs)).min(1)[selector]
        diff = np.abs(ETs_old - ETs).max()
        if diff &lt; epsilon or (diff &lt; 0.05 and ETs.max() - 1 &lt; max_diam):
            break
        if max_value is not None and ETs.max() &gt; max_value:
            return None
    return max(max_diam, ETs.max())


def _get_sparse_diameter(
    T: np.ndarray, epsilon: float = 0.001, max_value: float = None
) -&gt; float:
    num_states, num_actions, _ = T.shape

    T = np.moveaxis(T, -1, 0).reshape(num_states, num_states * num_actions)
    T = sparse.COO(T)
    next_ets = (
        lambda TT, ET: (TT * ET.reshape(-1, 1))
        .reshape((num_states - 1, num_states, num_actions))
        .sum(0)
        .todense()
    )

    diameter = -np.inf
    loop = (
        trange(num_states, desc=&#34;Calculating diameter&#34;, mininterval=5)
        if config.VERBOSE_LEVEL &gt; 0
        else range(num_states)
    )
    selector = np.ones(num_states, dtype=bool)
    for i in loop:
        selector[i] = False
        selector[i - 1] = True
        Te = T[i].reshape((num_states, num_actions))
        T_me = T[selector]

        ETs = np.zeros(num_states - 1)
        diff = np.inf
        for j in range(1_000_000):
            ETs_old = ETs.copy()
            ETs = (Te + next_ets(T_me, 1 + ETs)).min(1)[selector]
            diff = np.abs(ETs_old - ETs).max()
            if diff &lt; epsilon or (diff &lt; 0.05 and ETs.max() - 1 &lt; diameter):
                break
        diameter = max(diameter, ETs.max())
        if max_value is not None and diameter &gt; max_value:
            return None
    return diameter</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="colosseum.hardness.measures.diameter.get_diameter"><code class="name flex">
<span>def <span class="ident">get_diameter</span></span>(<span>T: numpy.ndarray, is_episodic: bool, max_value: float = None) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>returns the diameter for the transition matrix given in input. The is_episodic is only necessary to check whether
the dimensionality of the transition matrix is effectively correct. Note that, for the episodic setting, this
computes the diameter for the augmented state space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_diameter(T: np.ndarray, is_episodic: bool, max_value: float = None) -&gt; float:
    &#34;&#34;&#34;
    returns the diameter for the transition matrix given in input. The is_episodic is only necessary to check whether
    the dimensionality of the transition matrix is effectively correct. Note that, for the episodic setting, this
    computes the diameter for the augmented state space.
    &#34;&#34;&#34;
    assert (is_episodic and T.ndim == 4) or (not is_episodic and T.ndim == 3)
    if is_episodic:
        if config.get_available_cores() &gt;= 3:
            return _multi_thread_episodic_diameter_calculation(T, max_value=max_value)
        return _single_thread_episodic_diameter_calculation(T, max_value=max_value)

    if config.get_available_cores() &gt;= 3:
        return _continuous_multi_thread_diam(T, max_value=max_value)
    if T.shape[-1] &gt; 1000:
        return _get_sparse_diameter(T, max_value=max_value)
    return _continuous_single_thread_diam(T, max_value=max_value)</code></pre>
</details>
</dd>
<dt id="colosseum.hardness.measures.diameter.get_diameter_for_determinsitic_MDPs"><code class="name flex">
<span>def <span class="ident">get_diameter_for_determinsitic_MDPs</span></span>(<span>G: networkx.classes.digraph.DiGraph) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>returns the diameter for the given graph that represents an MDP. Note that this can be considerably slower than
the dynamic programming implementation we propose.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_diameter_for_determinsitic_MDPs(G: nx.DiGraph) -&gt; float:
    &#34;&#34;&#34;
    returns the diameter for the given graph that represents an MDP. Note that this can be considerably slower than
    the dynamic programming implementation we propose.
    &#34;&#34;&#34;
    A = nx.to_numpy_array(G, nonedge=np.inf)
    n, m = A.shape
    np.fill_diagonal(A, 0)  # diagonal elements should be zero
    for i in get_loop(range(n)):
        A = np.minimum(A, A[i, :][np.newaxis, :] + A[:, i][:, np.newaxis])
    return np.max(A, where=A != 0, initial=-np.inf)</code></pre>
</details>
</dd>
<dt id="colosseum.hardness.measures.diameter.get_in_episodic_diameter"><code class="name flex">
<span>def <span class="ident">get_in_episodic_diameter</span></span>(<span>H: int, T: numpy.ndarray, reachable_node: Iterable[ForwardRef('NODE_TYPE')], max_value: float = None) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>returns the diameter for the in episodic formulation. Note that in this case, the diameter will always be less than
the time horizon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_in_episodic_diameter(
    H: int,
    T: np.ndarray,
    reachable_node: Iterable[&#34;NODE_TYPE&#34;],
    max_value: float = None,
) -&gt; float:
    &#34;&#34;&#34;
    returns the diameter for the in episodic formulation. Note that in this case, the diameter will always be less than
    the time horizon.
    &#34;&#34;&#34;
    if config.get_available_cores() &gt;= 3:
        return _episodic_multi_thread_diam(H, T, reachable_node, max_value)
    return _episodic_single_thread_diam(H, T, reachable_node, max_value)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="colosseum.hardness.measures" href="index.html">colosseum.hardness.measures</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="colosseum.hardness.measures.diameter.get_diameter" href="#colosseum.hardness.measures.diameter.get_diameter">get_diameter</a></code></li>
<li><code><a title="colosseum.hardness.measures.diameter.get_diameter_for_determinsitic_MDPs" href="#colosseum.hardness.measures.diameter.get_diameter_for_determinsitic_MDPs">get_diameter_for_determinsitic_MDPs</a></code></li>
<li><code><a title="colosseum.hardness.measures.diameter.get_in_episodic_diameter" href="#colosseum.hardness.measures.diameter.get_in_episodic_diameter">get_in_episodic_diameter</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>